 /***************************************************************************** 
  * Project: RooFit                                                           * 
  *                                                                           * 
  * This code was autogenerated by RooClassFactory                            * 
  *****************************************************************************/ 

 // Your description goes here... 

#include "MGMExponentialPlusSinusoid.hh" 
#include "MGMPiecewiseRegions.hh"
#include "TMath.h"
using TMath::TwoPi;


 ClassImp(MGMExponentialPlusSinusoid) 
 MGMExponentialPlusSinusoid::MGMExponentialPlusSinusoid(
              const char *name, const char *title,
	      RooAbsReal& _x, 
              RooAbsReal& _c, 
              RooAbsReal& _ampl, 
              RooAbsReal& _freq, 
              RooAbsReal& _phase) : 
  MGMExponential(name, title, _x, _c), 
  fAmplitude("amplitude", "amplitude", this, _ampl),
  fFrequency("frequency", "frequency", this, _freq),
  fPhase("phase", "phase", this, _phase) 
{}

MGMExponentialPlusSinusoid::MGMExponentialPlusSinusoid(const MGMExponentialPlusSinusoid& other, const char* name) : 
  MGMExponential(other, name),
  fAmplitude("amplitude", this, other.fAmplitude),
  fFrequency("frequency", this, other.fFrequency),
  fPhase("phase", this, other.fPhase)
{}

Double_t MGMExponentialPlusSinusoid::evaluate() const 
{ 
  if (!fRegions || fRegions->IsInAcceptedRegion(x)) { 
    if (fAmplitude == 0.0) return MGMExponential::evaluate();
    else return exp(c*x)*(1 + fAmplitude*sin(TwoPi()*fFrequency*x + fPhase));
  }
  // Otherwise it is in a region which we have inserted, return 0
  //return 0;
  return 1e-16;
} 

Double_t MGMExponentialPlusSinusoid::IntegralValueAtPoint(Double_t point) const
{
  // This is only called by analyticalIntegral, and the check for fAmplitude !=
  // 0 has already been made.
  Double_t trig_arg = TwoPi()*fFrequency*point + fPhase;
  if ( c != 0.0 ) {
    Double_t scratch = c*c + TwoPi()*TwoPi()*fFrequency*fFrequency;
    return (1./(c*scratch))*exp(c*point)*(
                                      fAmplitude*c*c*sin(trig_arg) -
                                      TwoPi()*fAmplitude*c*fFrequency*cos(trig_arg) +
                                      scratch); 
  } else {
    return (point-fAmplitude/(TwoPi()*fFrequency))*cos(trig_arg);
  }
}

Double_t MGMExponentialPlusSinusoid::analyticalIntegral(Int_t code, const char* rangeName) const
{
   assert(code==1);
   if (fAmplitude == 0.0) return MGMExponential::analyticalIntegral(code, rangeName); 
   Double_t max = x.max(rangeName);
   Double_t min = x.min(rangeName);
   if (!fRegions) return (IntegralValueAtPoint(max) - IntegralValueAtPoint(min)); 

   Double_t sum = 0.0;
   fRegions->InitializeRegionIterator(min, max);
   const MGMPiecewiseRegions::MGMRegion* reg;
   while ( (reg = fRegions->GetNextRegion()) ) {
     sum += IntegralValueAtPoint(reg->fEnd) - IntegralValueAtPoint(reg->fBegin);
   }
   return sum; 
}

