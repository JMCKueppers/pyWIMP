 /***************************************************************************** 
  * Project: RooFit                                                           * 
  *                                                                           * 
  * This code was autogenerated by RooClassFactory                            * 
  *****************************************************************************/ 

 // Your description goes here... 

#include "MGMExponentialPlusSinusoid.hh" 
#include "MGMPiecewiseRegions.hh"
#include "TMath.h"
using TMath::TwoPi;


 ClassImp(MGMExponentialPlusSinusoid) 
 MGMExponentialPlusSinusoid::MGMExponentialPlusSinusoid(
              const char *name, const char *title,
              RooAbsReal& _x, 
              RooAbsReal& _per, 
              RooAbsReal& _phase) : 
  MGMPiecewiseFunction(name, title, _x), 
  fPeriod("period", "period", this, _per),
  fPhase("phase", "phase", this, _phase) 
{}

MGMExponentialPlusSinusoid::MGMExponentialPlusSinusoid(const MGMExponentialPlusSinusoid& other, const char* name) : 
  MGMPiecewiseFunction(other, name),
  fPeriod("period", this, other.fPeriod),
  fPhase("phase", this, other.fPhase)
{}

Double_t MGMExponentialPlusSinusoid::evaluate() const 
{ 
  Double_t val = 1e-16;
  if (!fRegions || fRegions->IsInAcceptedRegion(fVariable)) { 
    val = 0.5*(1 + sin(TwoPi()*(fVariable/fPeriod - fPhase))); 
  }
  // Otherwise it is in a region which we have inserted, return 0
  //return 0;
  return (val < 1e-16) ? 1e-16 : val;
} 

Double_t MGMExponentialPlusSinusoid::IntegralValueAtPoint(Double_t point) const
{
  return 0.5*(point - fPeriod*cos(TwoPi()*(point/fPeriod - fPhase))/TwoPi());
}

Double_t MGMExponentialPlusSinusoid::analyticalIntegral(Int_t code, const char* rangeName) const
{
   assert(code==1);
   Double_t max = fVariable.max(rangeName);
   Double_t min = fVariable.min(rangeName);
   if (!fRegions) return (IntegralValueAtPoint(max) - IntegralValueAtPoint(min)); 

   Double_t sum = 0.0;
   fRegions->InitializeRegionIterator(min, max);
   const MGMPiecewiseRegions::MGMRegion* reg;
   while ( (reg = fRegions->GetNextRegion()) ) {
     sum += IntegralValueAtPoint(reg->fEnd) - IntegralValueAtPoint(reg->fBegin);
   }
   return sum; 
}

